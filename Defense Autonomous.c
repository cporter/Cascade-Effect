#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     LIFT,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     LEFT_DRIVE,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     RIGHT_DRIVE,   tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    TUBE_MAN_B,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    TUBE_MAN_FL,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    TUBE_MAN_FR,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    BALL_DUMP,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "autonomous_functions.h"

tMotor DRIVEMOTORS[] = { LEFT_DRIVE, RIGHT_DRIVE };

void stopMotors(tMotor *DriveMotors) {
	int size = sizeof(DriveMotors) / sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 0;
	}
}

void forwardTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 100;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

task main() {
	waitForStart();
	forwardTime(100, DRIVEMOTORS);
}
