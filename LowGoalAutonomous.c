#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IR,             sensorI2CCustom)
#pragma config(Sensor, S4,     ARDUINO,        sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     LIFT,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LEFT_DRIVE,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     RIGHT_DRIVE,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    TUBE_MAN,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "autonomous_functions.h"

tMotor DRIVE_MOTORS[] = { LEFT_DRIVE, RIGHT_DRIVE };

void initialize_robot() {
	servo[TUBE_MAN] = 0;
}

int *parseArduinoData(tSensors board) {
	int packet[] = { 0, 0 };
	return packet;
}

int drive_off_ramp_with_IR() {
	return 0;
}

void stopMotors(tMotor *DriveMotors) {
	int size = sizeof(DriveMotors) / sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 0;
	}
}

void forwardTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 100;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void forwardSlowTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 20;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void backwardTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = -100;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void leftTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 2;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		if (i % 2 == 1) {
			motor[DriveMotors[i]] = -100;
		} else {
			motor[DriveMotors[i]] = 100;
		}
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void rightTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 2;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		if (i % 2 == 1) {
			motor[DriveMotors[i]] = 100;
		} else {
			motor[DriveMotors[i]] = -100;
		}
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

bool grab_tube(bool tubemanState) {
	servo[TUBE_MAN] = tubemanState ? 20 : 255;
	wait10Msec(100);
	tubemanState = tubemanState ? false : true;
	return tubemanState;
}

void dump_in_goal() {

}

void go_to_parking_zone() {

}

task main() {
	initialize_robot();
	bool tubemanState = false;
	waitForStart();
	forwardTime(40, DRIVE_MOTORS);
	forwardSlowTime(65, DRIVE_MOTORS);
	grab_tube(tubemanState);
	//rightTime(18, DRIVE_MOTORS);
	backwardTime(120, DRIVE_MOTORS);
	rightTime(45, DRIVE_MOTORS);
}
