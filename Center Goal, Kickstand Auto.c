#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S3,     IR_l,           sensorI2CCustom)
#pragma config(Sensor, S4,     IR_r,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     LIFT,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     LEFT_DRIVE,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     RIGHT_DRIVE,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    TUBE_MAN_B,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    BALL_DUMP,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "autonomous_functions.h"

tMotor DRIVE_MOTORS[] = { LEFT_DRIVE, RIGHT_DRIVE };

void initialize_robot() {
	servo[BALL_DUMP] = 0;
	servo[TUBE_MAN_B] = 0;
}

void stopMotors(tMotor *DriveMotors) {
	int size = sizeof(DriveMotors) / sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 0;
	}
}

void forwardTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = 100;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void backwardTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 5;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		motor[DriveMotors[i]] = -100;
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void leftTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 2;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		if (i % 2 == 1) {
			motor[DriveMotors[i]] = -100;
		} else {
			motor[DriveMotors[i]] = 100;
		}
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

void rightTime(int distance, tMotor *DriveMotors) {
	const int TIME_TO_INCHES = 2;
	int size = sizeof(DriveMotors)/sizeof(tMotor);
	for (int i = 0; i < size; ++i) {
		if (i % 2 == 1) {
			motor[DriveMotors[i]] = 100;
		} else {
			motor[DriveMotors[i]] = -100;
		}
	}
	wait10Msec(distance * TIME_TO_INCHES);
	stopMotors(DriveMotors);
}

int irDirLeft() {
	int dir, strength;

  if (HTIRS2readEnhanced(IR_l, dir, strength)) {
		return dir;
	} else {
		return 0;
	}
}

int irDirRight() {
	int dir, strength;

  if (HTIRS2readEnhanced(IR_r, dir, strength)) {
		return dir;
	} else {
		return 0;
	}
}

int irPowerLeft() {
	int dir, strength;

  if (HTIRS2readEnhanced(IR_l, dir, strength)) {
		return strength;
	} else {
		return 0;
	}
}

int irPowerRight() {
	int dir, strength;

  if (HTIRS2readEnhanced(IR_r, dir, strength)) {
		return strength;
	} else {
		return 0;
	}
}

void dump_balls() {
	servo[BALL_DUMP] = 120;
	wait10Msec(10);
	servo[BALL_DUMP] = 0;
}

void knock_over_kickstand() {
	leftTime(100, DRIVE_MOTORS);
	forwardTime(100, DRIVE_MOTORS);
}

void setSpeeds(int left, int right) {
	motor[LEFT_DRIVE] = left;
	motor[RIGHT_DRIVE] = right;
}

void irForward() {
	int zero_count = 0;

	setSpeeds(50, 50);
	wait10Msec(10);

	while (5 > zero_count) {
		int l_dir = irDirLeft();
		int r_dir = irDirRight();

		writeDebugStreamLine("Direction: %d, %d", l_dir, r_dir);

		if(0 == l_dir || 0 == r_dir) {
			++zero_count;
		}

		if (5 == l_dir && 5 == r_dir) {
			int left = irPowerLeft();
			int right = irPowerRight();
			writeDebugStreamLine("Power: %d, %d", left, right);

			int diff = left - right;
			if (10 > abs(diff)) {
				setSpeeds(20, 20);
			} else if(left > right) {
				writeDebugStreamLine("Turn Left");
				setSpeeds(50, -40);
			} else { // left < right
				writeDebugStreamLine("Turn Right");
				setSpeeds(-40, 50);
			}
		} else {
			if (l_dir > r_dir) {
				writeDebugStreamLine("Turn Right");
				setSpeeds(-40, 50);
			} else if (l_dir < r_dir) {
				writeDebugStreamLine("Turn Left");
				setSpeeds(50, -40);
			}
		}
		wait10Msec(1);
	}

	writeDebugStreamLine("Done!");
	stopMotors(DRIVE_MOTORS);
}

void driveToPositionOne() {
	setSpeeds(50, 50);
	wait10Msec(10);

    setSpeeds(-50, 50);
    wait10Msec(100);

    setSpeeds(50, 50);

    int iterations = 0;
    const int MAX_FORWARD_ITERATIONS = 30;

    while(MAX_FORWARD_ITERATIONS > iterations++) {
        int right = irDirRight ();
        if (9 == right) {
            break;
        }
        wait10Msec(10);
    }
    writeDebugStreamLine("Finished going forward after %d iterations", iterations);

    setSpeeds(50, -50);

    iterations = 0;
    const int MAX_ROTATE_ITERATIONS = 20;
    const int POWER_SAME_THRESHOLD = 10;
    while(MAX_ROTATE_ITERATIONS > iterations++) {
        int right_dir = irDirRight();
        int left_dir = irDirLeft ();
        if (5 == right_dir && 5 == left_dir) {
            int left_power = irPowerLeft();
            int right_power = irPowerRight ();
            if (POWER_SAME_THRESHOLD > abs(left_power - right_power)) {
                break;
            } else {
                writeDebugStreamLine("Powers: %d %d", left_power, right_power);
            }
        } else {
            writeDebugStreamLine("Directions: %d %d", left_dir, right_dir);
        }
        wait10Msec(10);
    }
    setSpeeds(0, 0);
    writeDebugStreamLine("Finished turning right after %d iterations", iterations);
}

void driveToCenterGoal () {
    int left = irDirLeft ();
    int right = irDirRight ();

    if (5 != left || 5 != right) {
        driveToPositionOne();
    }

    irForward();
}

task main() {
	initialize_robot();

	//waitForStart();

    driveToCenterGoal();
    

	//initialDrive();
	//IR_drive_to_center_goal(goalPos);
	//dump_balls();
	//knock_over_kickstand();

}
