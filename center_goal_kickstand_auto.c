#pragma config(Hubs, S1, HTMotor, HTServo, HTMotor, none)
#pragma config(Sensor, S3, IR_l, sensorI2CCustom)
#pragma config(Sensor, S4, IR_r, sensorI2CCustom)
#pragma config(Motor, mtr_S1_C1_1, motorD, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C1_2, LIFT, tmotorTetrix, openLoop, encoder)
#pragma config(Motor, mtr_S1_C3_1, LEFT_DRIVE, tmotorTetrix, openLoop, encoder)
#pragma config(Motor, mtr_S1_C3_2, RIGHT_DRIVE, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo, srvo_S1_C2_1, TUBE_MAN_B, tServoStandard)
#pragma config(Servo, srvo_S1_C2_2, servo2, tServoNone)
#pragma config(Servo, srvo_S1_C2_3, servo3, tServoNone)
#pragma config(Servo, srvo_S1_C2_4, servo4, tServoNone)
#pragma config(Servo, srvo_S1_C2_5, servo5, tServoNone)
#pragma config(Servo, srvo_S1_C2_6, BALL_DUMP, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

#include "JoystickDriver.c"
#include "autonomous_functions.h"

void initialize_robot () {
    servo[BALL_DUMP] = 0;
    servo[TUBE_MAN_B] = 0;
}

int irDirLeft () {
    int dir, strength;

    if (HTIRS2readEnhanced (IR_l, dir, strength)) {
        return dir;
    } else {
        return 0;
    }
}

int irDirRight () {
    int dir, strength;

    if (HTIRS2readEnhanced (IR_r, dir, strength)) {
        return dir;
    } else {
        return 0;
    }
}

int irPowerLeft () {
    int dir, strength;

    if (HTIRS2readEnhanced (IR_l, dir, strength)) {
        return strength;
    } else {
        return 0;
    }
}

int irPowerRight () {
    int dir, strength;

    if (HTIRS2readEnhanced (IR_r, dir, strength)) {
        return strength;
    } else {
        return 0;
    }
}

void setSpeeds (int left, int right) {
    motor[LEFT_DRIVE] = left;
    motor[RIGHT_DRIVE] = right;
}

void setSpeedsCrawlAhead () { setSpeeds (20, 20); }
void setSpeedsCrawlBack () { setSpeeds (-20, -20); }
void setSpeedsSpiritedAhead () { setSpeeds (50, 50); }
void setSpeedsAllAheadFull () { setSpeeds (100, 100); }
void setSpeedsLeftTurn () { setSpeeds (20, 40); }
void setSpeedsRightTurn () { setSpeeds (40, 20); }
void setSpeedsLeftPivot () { setSpeeds (-50, 50); }
void setSpeedsRightPivot () { setSpeeds (50, -50); }
void setSpeedsStop () { setSpeeds (0, 0); }

void sleep (float seconds) { wait10Msec (int(seconds * 100.0)); }

// Undefine this if you want to point the sensors inward
#define SENSORS_FORWARD 1

#ifdef SENSORS_FORWARD
const int LEFT_SENSOR_CENTER = 5;
const int RIGHT_SENSOR_CENTER = 5;
#else
const int LEFT_SENSOR_CENTER = 1;
const int RIGHT_SENSOR_CENTER = 9;
#endif

void dumpBallsInCenterGoal () {
    const float RAISE_LOWER_DURATION = 0.5;
    // Setting this initially low, just in case.
    const float SERVO_DUMP_DURATION = 1.0;
    // raise the dumping arm
    motor[LIFT] = 100;
    sleep (RAISE_LOWER_DURATION);
    motor[LIFT] = 0;

    servo[BALL_DUMP] = 120;
    sleep (SERVO_DUMP_DURATION);
    servo[BALL_DUMP] = 0;

    motor[LIFT] = -100;
    sleep (RAISE_LOWER_DURATION);
    motor[LIFT] = 0;
}

// Assumes that we've just dumped in the center goal. We're a few inches
// away from the game element. So we'll nedd to back up a bit, turn right
// 45 degrees, drive forward a bit, turn left 45 degrees and then drive
// forward in a spirited way.
void knockOverKickstand () {
    const float BACKUP_DURATION = 0.5;
    const float ROTATE_DURATION = 1.0;
    const float FIRST_FORWARD_DURATION = 1.0;
    const float RAMMING_DURATION = 2.0;

    setSpeedsCrawlBack ();
    sleep (BACKUP_DURATION);
    setSpeedsRotateRight ();
    sleep (ROTATE_DURATION);
    setSpeedsCrawlAhead ();
    sleep (FIRST_FORWARD_DURATION);
    setSpeedsRotateLeft ();
    sleep (ROTATE_DURATION);
    setSpeedsAllAheadFull ();
    sleep (RAMMING_DURATION);
    setSpeedsStop ();
}

void guidedIRForward () {
    int zero_count = 0;

    setSpeedsSpiritedAhead ();
    sleep (0.1);

    while (5 > zero_count) {
        int l_dir = irDirLeft ();
        int r_dir = irDirRight ();

        writeDebugStreamLine ("Direction: %d, %d", l_dir, r_dir);

        if (0 == l_dir || 0 == r_dir) {
            ++zero_count;
        }

        if (LEFT_SENSOR_CENTER == l_dir && RIGHT_SENSOR_CENTER == r_dir) {
            int left = irPowerLeft ();
            int right = irPowerRight ();
            writeDebugStreamLine ("Power: %d, %d", left, right);

            int diff = left - right;
            if (10 > abs (diff)) {
                setSpeeds (20, 20);
            } else if (left > right) {
                writeDebugStreamLine ("Turn Left");
                setSpeedsLeftTurn ();
            } else { // left < right
                writeDebugStreamLine ("Turn Right");
                setSpeedsRightTurn ();
            }
        }
        sleep (0.01);
    }

    writeDebugStreamLine ("Done!");
    setSpeedsStop ();
}

bool doneDrivingForwardTowardsPositionOne () {
#ifdef SENSORS_FORWARD
    return 9 == irDirRight ();
#else
    return 5 == irDirLeft ();
#endif
}

void driveToPositionOne () {
    const float INITIAL_FORWARD_DURATION = 0.1;
    const float INITIAL_LEFT_TURN_DURATION = 1.0;

    // Get away from the wall
    setSpeedsSpiritedAhead ();
    sleep (0.1);

    // Turn left a bit
    setSpeedsLeftPivot ();
    sleep (INITIAL_LEFT_TURN_DURATION);

    // Drive forward until the IR beacon is at position 9 for the right
    // IR sensor

    int iterations = 0;
    const int MAX_FORWARD_ITERATIONS = 30;
    setSpeedsSpiritedAhead ();
    while (MAX_FORWARD_ITERATIONS > iterations++) {
        if (doneDrivingForwardTowardsPositionOne ()) {
            break;
        }
        sleep (0.1);
    }
    writeDebugStreamLine ("Finished going forward after %d iterations",
                          iterations);

    // Turn right until the IR beacon is at position 5 for both sensors
    // and the power difference between the two is minimal.
    setSpeedsRightPivot ();
    iterations = 0;
    const int MAX_ROTATE_ITERATIONS = 20;
    const int POWER_SAME_THRESHOLD = 10;
    while (MAX_ROTATE_ITERATIONS > iterations++) {
        int right_dir = irDirRight ();
        int left_dir = irDirLeft ();
        if (LEFT_SENSOR_CENTER == right_dir &&
            RIGHT_SENSOR_CENTER == left_dir) {
            int left_power = irPowerLeft ();
            int right_power = irPowerRight ();
            if (POWER_SAME_THRESHOLD > abs (left_power - right_power)) {
                break;
            } else {
                writeDebugStreamLine ("Powers: %d %d", left_power, right_power);
            }
        } else {
            writeDebugStreamLine ("Directions: %d %d", left_dir, right_dir);
        }
        sleep (0.1);
    }

    // Stop!
    setSpeedsStop ();
    writeDebugStreamLine ("Finished turning right after %d iterations",
                          iterations);
}

void driveToCenterGoal () {
    int left = irDirLeft ();
    int right = irDirRight ();

    // The center goal shows up at 5/5
    if (5 != left || 5 != right) {
        driveToPositionOne ();
    }

    guidedIRForward ();
}

task main () {
    initialize_robot ();

    // waitForStart();

    driveToCenterGoal ();
    dumpBallsInCenterGoal ();
    knockOverKickstand ();
}
